{"ast":null,"code":"\"use client\";\n\nvar _jsxFileName = \"/home/shanavas/Documents/portfolio/src/components/ui/pixelated-canvas.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const PixelatedCanvas = ({\n  src,\n  width = 400,\n  height = 500,\n  cellSize = 3,\n  dotScale = 0.9,\n  shape = \"square\",\n  backgroundColor = \"#000000\",\n  dropoutStrength = 0.4,\n  interactive = false,\n  distortionStrength = 3,\n  distortionRadius = 80,\n  distortionMode = \"swirl\",\n  followSpeed = 0.2,\n  jitterStrength = 4,\n  jitterSpeed = 4,\n  sampleAverage = false,\n  tintColor = \"#FFFFFF\",\n  tintStrength = 0.2,\n  className = \"\",\n  onError\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const [imageData, setImageData] = useState(null);\n  const [mousePos, setMousePos] = useState({\n    x: 0,\n    y: 0\n  });\n  const animationFrameRef = useRef(null);\n\n  // Load image\n  useEffect(() => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0, width, height);\n      const data = ctx.getImageData(0, 0, width, height);\n      setImageData(data);\n    };\n    img.onerror = () => {\n      if (onError) onError();\n    };\n    img.src = src;\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [src, width, height, onError]);\n\n  // Handle mouse movement\n  const handleMouseMove = e => {\n    if (!interactive) return;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    setMousePos({\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    });\n  };\n\n  // Render pixelated effect\n  useEffect(() => {\n    if (!imageData || !canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const render = () => {\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(0, 0, width, height);\n      const cols = Math.ceil(width / cellSize);\n      const rows = Math.ceil(height / cellSize);\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const x = col * cellSize;\n          const y = row * cellSize;\n\n          // Sample pixel color\n          let r = 0,\n            g = 0,\n            b = 0,\n            a = 0;\n          let sampleCount = 0;\n          if (sampleAverage) {\n            // Average sampling within cell\n            for (let dy = 0; dy < cellSize; dy++) {\n              for (let dx = 0; dx < cellSize; dx++) {\n                const px = Math.min(Math.floor(x + dx), width - 1);\n                const py = Math.min(Math.floor(y + dy), height - 1);\n                const idx = (py * width + px) * 4;\n                r += imageData.data[idx];\n                g += imageData.data[idx + 1];\n                b += imageData.data[idx + 2];\n                a += imageData.data[idx + 3];\n                sampleCount++;\n              }\n            }\n            r /= sampleCount;\n            g /= sampleCount;\n            b /= sampleCount;\n            a /= sampleCount;\n          } else {\n            // Center point sampling\n            const px = Math.min(Math.floor(x + cellSize / 2), width - 1);\n            const py = Math.min(Math.floor(y + cellSize / 2), height - 1);\n            const idx = (py * width + px) * 4;\n            r = imageData.data[idx];\n            g = imageData.data[idx + 1];\n            b = imageData.data[idx + 2];\n            a = imageData.data[idx + 3];\n          }\n\n          // Apply tint\n          if (tintStrength > 0) {\n            const tint = hexToRgb(tintColor);\n            r = r * (1 - tintStrength) + tint.r * tintStrength;\n            g = g * (1 - tintStrength) + tint.g * tintStrength;\n            b = b * (1 - tintStrength) + tint.b * tintStrength;\n          }\n\n          // Dropout effect\n          if (Math.random() < dropoutStrength) {\n            continue;\n          }\n\n          // Apply interactive distortion\n          let finalX = x + cellSize / 2;\n          let finalY = y + cellSize / 2;\n          if (interactive && mousePos.x && mousePos.y) {\n            const dx = finalX - mousePos.x;\n            const dy = finalY - mousePos.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < distortionRadius) {\n              const strength = (1 - distance / distortionRadius) * distortionStrength;\n              if (distortionMode === \"swirl\") {\n                const angle = strength * 0.5;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                finalX += (dx * cos - dy * sin) * 0.3;\n                finalY += (dx * sin + dy * cos) * 0.3;\n              } else if (distortionMode === \"push\") {\n                finalX += dx / distance * strength;\n                finalY += dy / distance * strength;\n              }\n            }\n          }\n\n          // Apply jitter\n          const jitterTime = Date.now() * 0.001 * jitterSpeed;\n          const jitterX = Math.sin(jitterTime + col * 0.5) * jitterStrength;\n          const jitterY = Math.cos(jitterTime + row * 0.5) * jitterStrength;\n          finalX += jitterX;\n          finalY += jitterY;\n\n          // Draw shape\n          ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a / 255})`;\n          const size = cellSize * dotScale;\n          if (shape === \"circle\") {\n            ctx.beginPath();\n            ctx.arc(finalX, finalY, size / 2, 0, Math.PI * 2);\n            ctx.fill();\n          } else {\n            ctx.fillRect(finalX - size / 2, finalY - size / 2, size, size);\n          }\n        }\n      }\n      if (jitterStrength > 0 || interactive) {\n        animationFrameRef.current = requestAnimationFrame(render);\n      }\n    };\n    render();\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [imageData, cellSize, dotScale, shape, backgroundColor, dropoutStrength, interactive, distortionStrength, distortionRadius, distortionMode, followSpeed, jitterStrength, jitterSpeed, sampleAverage, tintColor, tintStrength, mousePos, width, height]);\n\n  // Helper function to convert hex to RGB\n  const hexToRgb = hex => {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    } : {\n      r: 255,\n      g: 255,\n      b: 255\n    };\n  };\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: width,\n    height: height,\n    className: className,\n    onMouseMove: handleMouseMove,\n    onMouseLeave: () => setMousePos({\n      x: 0,\n      y: 0\n    }),\n    style: {\n      maxWidth: '100%',\n      height: 'auto',\n      cursor: interactive ? 'pointer' : 'default'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n};\n_s(PixelatedCanvas, \"fhI1ETdRjvnfH95gClY0sysBTOE=\");\n_c = PixelatedCanvas;\nvar _c;\n$RefreshReg$(_c, \"PixelatedCanvas\");","map":{"version":3,"names":["_jsxFileName","_s","$RefreshSig$","React","useRef","useEffect","useState","jsxDEV","_jsxDEV","PixelatedCanvas","src","width","height","cellSize","dotScale","shape","backgroundColor","dropoutStrength","interactive","distortionStrength","distortionRadius","distortionMode","followSpeed","jitterStrength","jitterSpeed","sampleAverage","tintColor","tintStrength","className","onError","canvasRef","imageData","setImageData","mousePos","setMousePos","x","y","animationFrameRef","img","Image","crossOrigin","onload","canvas","document","createElement","ctx","getContext","drawImage","data","getImageData","onerror","current","cancelAnimationFrame","handleMouseMove","e","rect","getBoundingClientRect","clientX","left","clientY","top","render","fillStyle","fillRect","cols","Math","ceil","rows","row","col","r","g","b","a","sampleCount","dy","dx","px","min","floor","py","idx","tint","hexToRgb","random","finalX","finalY","distance","sqrt","strength","angle","cos","sin","jitterTime","Date","now","jitterX","jitterY","round","size","beginPath","arc","PI","fill","requestAnimationFrame","hex","result","exec","parseInt","ref","onMouseMove","onMouseLeave","style","maxWidth","cursor","fileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/shanavas/Documents/portfolio/src/components/ui/pixelated-canvas.jsx"],"sourcesContent":["\"use client\";\nimport React, { useRef, useEffect, useState } from 'react';\n\nexport const PixelatedCanvas = ({\n  src,\n  width = 400,\n  height = 500,\n  cellSize = 3,\n  dotScale = 0.9,\n  shape = \"square\",\n  backgroundColor = \"#000000\",\n  dropoutStrength = 0.4,\n  interactive = false,\n  distortionStrength = 3,\n  distortionRadius = 80,\n  distortionMode = \"swirl\",\n  followSpeed = 0.2,\n  jitterStrength = 4,\n  jitterSpeed = 4,\n  sampleAverage = false,\n  tintColor = \"#FFFFFF\",\n  tintStrength = 0.2,\n  className = \"\",\n  onError\n}) => {\n  const canvasRef = useRef(null);\n  const [imageData, setImageData] = useState(null);\n  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n  const animationFrameRef = useRef(null);\n\n  // Load image\n  useEffect(() => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas.getContext('2d');\n      \n      ctx.drawImage(img, 0, 0, width, height);\n      const data = ctx.getImageData(0, 0, width, height);\n      setImageData(data);\n    };\n    \n    img.onerror = () => {\n      if (onError) onError();\n    };\n    \n    img.src = src;\n    \n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [src, width, height, onError]);\n\n  // Handle mouse movement\n  const handleMouseMove = (e) => {\n    if (!interactive) return;\n    \n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const rect = canvas.getBoundingClientRect();\n    setMousePos({\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    });\n  };\n\n  // Render pixelated effect\n  useEffect(() => {\n    if (!imageData || !canvasRef.current) return;\n\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    const render = () => {\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(0, 0, width, height);\n\n      const cols = Math.ceil(width / cellSize);\n      const rows = Math.ceil(height / cellSize);\n\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const x = col * cellSize;\n          const y = row * cellSize;\n          \n          // Sample pixel color\n          let r = 0, g = 0, b = 0, a = 0;\n          let sampleCount = 0;\n          \n          if (sampleAverage) {\n            // Average sampling within cell\n            for (let dy = 0; dy < cellSize; dy++) {\n              for (let dx = 0; dx < cellSize; dx++) {\n                const px = Math.min(Math.floor(x + dx), width - 1);\n                const py = Math.min(Math.floor(y + dy), height - 1);\n                const idx = (py * width + px) * 4;\n                \n                r += imageData.data[idx];\n                g += imageData.data[idx + 1];\n                b += imageData.data[idx + 2];\n                a += imageData.data[idx + 3];\n                sampleCount++;\n              }\n            }\n            r /= sampleCount;\n            g /= sampleCount;\n            b /= sampleCount;\n            a /= sampleCount;\n          } else {\n            // Center point sampling\n            const px = Math.min(Math.floor(x + cellSize / 2), width - 1);\n            const py = Math.min(Math.floor(y + cellSize / 2), height - 1);\n            const idx = (py * width + px) * 4;\n            \n            r = imageData.data[idx];\n            g = imageData.data[idx + 1];\n            b = imageData.data[idx + 2];\n            a = imageData.data[idx + 3];\n          }\n\n          // Apply tint\n          if (tintStrength > 0) {\n            const tint = hexToRgb(tintColor);\n            r = r * (1 - tintStrength) + tint.r * tintStrength;\n            g = g * (1 - tintStrength) + tint.g * tintStrength;\n            b = b * (1 - tintStrength) + tint.b * tintStrength;\n          }\n\n          // Dropout effect\n          if (Math.random() < dropoutStrength) {\n            continue;\n          }\n\n          // Apply interactive distortion\n          let finalX = x + cellSize / 2;\n          let finalY = y + cellSize / 2;\n          \n          if (interactive && mousePos.x && mousePos.y) {\n            const dx = finalX - mousePos.x;\n            const dy = finalY - mousePos.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance < distortionRadius) {\n              const strength = (1 - distance / distortionRadius) * distortionStrength;\n              \n              if (distortionMode === \"swirl\") {\n                const angle = strength * 0.5;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                finalX += (dx * cos - dy * sin) * 0.3;\n                finalY += (dx * sin + dy * cos) * 0.3;\n              } else if (distortionMode === \"push\") {\n                finalX += (dx / distance) * strength;\n                finalY += (dy / distance) * strength;\n              }\n            }\n          }\n\n          // Apply jitter\n          const jitterTime = Date.now() * 0.001 * jitterSpeed;\n          const jitterX = Math.sin(jitterTime + col * 0.5) * jitterStrength;\n          const jitterY = Math.cos(jitterTime + row * 0.5) * jitterStrength;\n          finalX += jitterX;\n          finalY += jitterY;\n\n          // Draw shape\n          ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a / 255})`;\n          \n          const size = cellSize * dotScale;\n          \n          if (shape === \"circle\") {\n            ctx.beginPath();\n            ctx.arc(finalX, finalY, size / 2, 0, Math.PI * 2);\n            ctx.fill();\n          } else {\n            ctx.fillRect(finalX - size / 2, finalY - size / 2, size, size);\n          }\n        }\n      }\n\n      if (jitterStrength > 0 || interactive) {\n        animationFrameRef.current = requestAnimationFrame(render);\n      }\n    };\n\n    render();\n\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    imageData,\n    cellSize,\n    dotScale,\n    shape,\n    backgroundColor,\n    dropoutStrength,\n    interactive,\n    distortionStrength,\n    distortionRadius,\n    distortionMode,\n    followSpeed,\n    jitterStrength,\n    jitterSpeed,\n    sampleAverage,\n    tintColor,\n    tintStrength,\n    mousePos,\n    width,\n    height\n  ]);\n\n  // Helper function to convert hex to RGB\n  const hexToRgb = (hex) => {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    } : { r: 255, g: 255, b: 255 };\n  };\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={width}\n      height={height}\n      className={className}\n      onMouseMove={handleMouseMove}\n      onMouseLeave={() => setMousePos({ x: 0, y: 0 })}\n      style={{\n        maxWidth: '100%',\n        height: 'auto',\n        cursor: interactive ? 'pointer' : 'default'\n      }}\n    />\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}